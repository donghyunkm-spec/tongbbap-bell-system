const express = require('express');
const WebSocket = require('ws');
const http = require('http');
const path = require('path');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// Îß§Ïû•Î≥Ñ Îç∞Ïù¥ÌÑ∞ Î∂ÑÎ¶¨
const stores = {
  '3ru': {
    displayClients: new Map(),
    inputClients: new Map(),
    currentNumbers: [],
    currentDisplayMode: 'WAITING',
    name: '3Î£®Ï†ê'
  },
  '1ru': {
    displayClients: new Map(),
    inputClients: new Map(),
    currentNumbers: [],
    currentDisplayMode: 'WAITING',
    name: '1Î£®Ï†ê'
  }
};

const PORT = process.env.PORT || 3000;

function addClient(store, clientMap, ws, req) {
  const clientInfo = {
    ws: ws,
    ip: req.socket.remoteAddress,
    userAgent: req.headers['user-agent'] || 'Unknown',
    connectTime: new Date(),
    lastPing: new Date(),
    isAlive: true,
    store: store
  };
  clientMap.set(ws, clientInfo);
  return clientInfo;
}

function removeClient(clientMap, ws) {
  return clientMap.delete(ws);
}

function getClientInfo(ws) {
  // Î™®Îì† Îß§Ïû•ÏóêÏÑú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï∞æÍ∏∞
  for (const storeKey in stores) {
    const store = stores[storeKey];
    if (store.displayClients.has(ws)) {
      return { client: store.displayClients.get(ws), store: storeKey, type: 'display' };
    }
    if (store.inputClients.has(ws)) {
      return { client: store.inputClients.get(ws), store: storeKey, type: 'input' };
    }
  }
  return null;
}

app.get('/health', (req, res) => {
  const now = new Date();
  const result = {};
  
  for (const storeKey in stores) {
    const store = stores[storeKey];
    const displayStats = Array.from(store.displayClients.values()).map(client => ({
      ip: client.ip,
      connected: Math.floor((now - client.connectTime) / 1000) + 's',
      lastPing: Math.floor((now - client.lastPing) / 1000) + 's ago',
      alive: client.isAlive
    }));
    
    const inputStats = Array.from(store.inputClients.values()).map(client => ({
      ip: client.ip,
      connected: Math.floor((now - client.connectTime) / 1000) + 's',
      lastPing: Math.floor((now - client.lastPing) / 1000) + 's ago',
      alive: client.isAlive
    }));

    result[store.name] = {
      currentMode: store.currentDisplayMode,
      displays: {
        count: store.displayClients.size,
        clients: displayStats
      },
      inputs: {
        count: store.inputClients.size,
        clients: inputStats
      },
      currentNumbers: store.currentNumbers
    };
  }

  res.json({ 
    status: 'ok',
    timestamp: now.toISOString(),
    stores: result
  });
});

app.get('/status', (req, res) => {
  const result = {};
  for (const storeKey in stores) {
    const store = stores[storeKey];
    result[store.name] = {
      currentMode: store.currentDisplayMode,
      displays: store.displayClients.size,
      inputs: store.inputClients.size,
      currentNumbers: store.currentNumbers
    };
  }

  res.json({
    server: 'running',
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    stores: result,
    timestamp: new Date().toISOString()
  });
});

const HEARTBEAT_INTERVAL = 300000;
const CLIENT_TIMEOUT = 300000;

function heartbeat() {
  console.log(`üíì ÌïòÌä∏ÎπÑÌä∏ Ï≤¥ÌÅ¨ ÏãúÏûë`);
  
  for (const storeKey in stores) {
    const store = stores[storeKey];
    console.log(`   ${store.name} - Display: ${store.displayClients.size}, Input: ${store.inputClients.size}`);
    
    const deadDisplays = [];
    store.displayClients.forEach((clientInfo, ws) => {
      if (ws.readyState === WebSocket.OPEN) {
        if (clientInfo.isAlive === false) {
          console.log(`üíÄ ${store.name} Display ÏùëÎãµ ÏóÜÏùå (${clientInfo.ip})`);
          ws.terminate();
          deadDisplays.push(ws);
        } else {
          clientInfo.isAlive = false;
          try {
            ws.send(JSON.stringify({ type: 'PING', timestamp: Date.now() }));
          } catch (error) {
            console.error(`‚ùå ${store.name} Display PING Ïã§Ìå®:`, error.message);
            deadDisplays.push(ws);
          }
        }
      } else {
        deadDisplays.push(ws);
      }
    });

    const deadInputs = [];
    store.inputClients.forEach((clientInfo, ws) => {
      if (ws.readyState === WebSocket.OPEN) {
        if (clientInfo.isAlive === false) {
          console.log(`üíÄ ${store.name} Input ÏùëÎãµ ÏóÜÏùå (${clientInfo.ip})`);
          ws.terminate();
          deadInputs.push(ws);
        } else {
          clientInfo.isAlive = false;
          try {
            ws.send(JSON.stringify({ type: 'PING', timestamp: Date.now() }));
          } catch (error) {
            console.error(`‚ùå ${store.name} Input PING Ïã§Ìå®:`, error.message);
            deadInputs.push(ws);
          }
        }
      } else {
        deadInputs.push(ws);
      }
    });

    deadDisplays.forEach(ws => removeClient(store.displayClients, ws));
    deadInputs.forEach(ws => removeClient(store.inputClients, ws));

    if (deadDisplays.length > 0) {
      console.log(`üì∫ ${store.name} ÎîîÏä§ÌîåÎ†àÏù¥ ${deadDisplays.length}Í∞ú Ï†ïÎ¶¨Îê®`);
      if (store.displayClients.size === 0) {
        notifyInputClients(storeKey, { type: 'DISPLAY_OFF', reason: 'all_disconnected' });
      }
    }
  }
}

const heartbeatTimer = setInterval(heartbeat, HEARTBEAT_INTERVAL);

function cleanupOldConnections() {
  const now = Date.now();
  
  for (const storeKey in stores) {
    const store = stores[storeKey];
    const oldDisplays = [];
    const oldInputs = [];

    store.displayClients.forEach((clientInfo, ws) => {
      if (now - clientInfo.lastPing.getTime() > CLIENT_TIMEOUT) {
        oldDisplays.push(ws);
      }
    });

    store.inputClients.forEach((clientInfo, ws) => {
      if (now - clientInfo.lastPing.getTime() > CLIENT_TIMEOUT) {
        oldInputs.push(ws);
      }
    });

    oldDisplays.forEach(ws => {
      ws.terminate();
      removeClient(store.displayClients, ws);
    });

    oldInputs.forEach(ws => {
      ws.terminate();
      removeClient(store.inputClients, ws);
    });

    if (oldDisplays.length > 0 && store.displayClients.size === 0) {
      notifyInputClients(storeKey, { type: 'DISPLAY_OFF', reason: 'timeout_cleanup' });
    }
  }
}

const cleanupTimer = setInterval(cleanupOldConnections, 5 * 60 * 1000);

// Ï†ïÏ†Å ÌååÏùº Ï†úÍ≥µ
app.use(express.static(__dirname));

// === ÎùºÏö∞ÌåÖ ÏÑ§Ï†ï ===
// 3Î£®Ï†ê ÏãúÏä§ÌÖú
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'input.html'));
});

app.get('/input.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'input.html'));
});

app.get('/display.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'display.html'));
});

// 1Î£®Ï†ê ÏãúÏä§ÌÖú  
app.get('/1ru', (req, res) => {
  res.sendFile(path.join(__dirname, 'input1.html'));
});

app.get('/input1.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'input1.html'));
});

app.get('/display1.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'display1.html'));
});

wss.on('connection', (ws, req) => {
  const clientIP = req.socket.remoteAddress;
  const userAgent = req.headers['user-agent'] || 'Unknown';
  console.log(`üîó ÏÉà ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞: ${clientIP}`);

  ws.on('message', (data) => {
    const message = data.toString();
    console.log(`üì© Î∞õÏùÄ Î©îÏãúÏßÄ (${clientIP}):`, message);

    // PONG ÏùëÎãµ Ï≤òÎ¶¨
    if (message.startsWith('{') && message.includes('PONG')) {
      try {
        const pongData = JSON.parse(message);
        if (pongData.type === 'PONG') {
          const clientInfo = getClientInfo(ws);
          if (clientInfo && clientInfo.client) {
            clientInfo.client.isAlive = true;
            clientInfo.client.lastPing = new Date();
            console.log(`üèì ${stores[clientInfo.store].name} PONG Î∞õÏùå (${clientIP})`);
          }
          return;
        }
      } catch (e) {}
    }

    // Îß§Ïû• Íµ¨Î∂ÑÌï¥ÏÑú ÎîîÏä§ÌîåÎ†àÏù¥/ÏûÖÎ†• ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù
    if (message === 'DISPLAY' || message === 'DISPLAY:3ru' || message === 'DISPLAY:1ru') {
      let storeKey = '3ru'; // Í∏∞Î≥∏Í∞í
      
      if (message === 'DISPLAY:1ru') {
        storeKey = '1ru';
      } else if (message === 'DISPLAY:3ru') {
        storeKey = '3ru';
      }
      
      const store = stores[storeKey];
      const clientInfo = addClient(storeKey, store.displayClients, ws, req);
      console.log(`üì∫ ${store.name} ÎîîÏä§ÌîåÎ†àÏù¥ Îì±Î°ù: ${clientIP} (Ï¥ù ${store.displayClients.size}Í∞ú)`);
      
      notifyInputClients(storeKey, { 
        type: 'DISPLAY_ON', 
        count: store.displayClients.size,
        timestamp: new Date().toISOString()
      });
      
      try {
        ws.send(JSON.stringify({
          type: 'MODE',
          mode: store.currentDisplayMode,
          timestamp: new Date().toISOString()
        }));
      } catch (error) {
        console.error(`‚ùå ${store.name} Î™®Îìú Ï†ÑÏÜ° Ïã§Ìå®:`, error.message);
      }
      
      if (store.currentDisplayMode === 'CALL' && store.currentNumbers.length > 0) {
        try {
          ws.send(JSON.stringify({
            type: 'CALL',
            list: [...store.currentNumbers],
            timestamp: new Date().toISOString()
          }));
        } catch (error) {
          console.error(`‚ùå ${store.name} Î≤àÌò∏ Ï†ÑÏÜ° Ïã§Ìå®:`, error.message);
        }
      }
      
    } else if (message === 'INPUT' || message === 'INPUT:3ru' || message === 'INPUT:1ru') {
      let storeKey = '3ru'; // Í∏∞Î≥∏Í∞í
      
      if (message === 'INPUT:1ru') {
        storeKey = '1ru';
      } else if (message === 'INPUT:3ru') {
        storeKey = '3ru';
      }
      
      const store = stores[storeKey];
      const clientInfo = addClient(storeKey, store.inputClients, ws, req);
      console.log(`üì± ${store.name} ÏûÖÎ†• ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù: ${clientIP} (Ï¥ù ${store.inputClients.size}Í∞ú)`);
      
      try {
        if (store.displayClients.size > 0) {
          ws.send(JSON.stringify({ 
            type: 'DISPLAY_ON', 
            count: store.displayClients.size,
            timestamp: new Date().toISOString()
          }));
        } else {
          ws.send(JSON.stringify({ 
            type: 'DISPLAY_OFF', 
            reason: 'no_displays',
            timestamp: new Date().toISOString()
          }));
        }
        
        if (store.currentNumbers.length > 0) {
          ws.send(JSON.stringify({ 
            type: 'CALL', 
            list: [...store.currentNumbers],
            timestamp: new Date().toISOString()
          }));
        }
      } catch (error) {
        console.error(`‚ùå ${store.name} ÏûÖÎ†• ÏÉÅÌÉú Ï†ÑÏÜ° Ïã§Ìå®:`, error.message);
      }
      
    } else {
      // Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïãú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Ïñ¥Îäê Îß§Ïû•Ïù∏ÏßÄ ÌôïÏù∏
      const clientInfo = getClientInfo(ws);
      if (clientInfo) {
        processMessage(clientInfo.store, message, clientIP);
      }
    }
  });

  ws.on('close', (code, reason) => {
    const clientInfo = getClientInfo(ws);
    if (clientInfo) {
      const store = stores[clientInfo.store];
      const wasDisplay = removeClient(store.displayClients, ws);
      const wasInput = removeClient(store.inputClients, ws);
      
      console.log(`‚ùå ${store.name} ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ìï¥Ï†ú: ${clientIP}`);
      
      if (wasDisplay) {
        console.log(`üì∫ ${store.name} ÎîîÏä§ÌîåÎ†àÏù¥ Ìï¥Ï†ú - ÎÇ®ÏùÄ Í∞úÏàò: ${store.displayClients.size}`);
        if (store.displayClients.size === 0) {
          notifyInputClients(clientInfo.store, { 
            type: 'DISPLAY_OFF', 
            reason: 'disconnected',
            timestamp: new Date().toISOString()
          });
        }
      }
      
      if (wasInput) {
        console.log(`üì± ${store.name} ÏûÖÎ†• ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ìï¥Ï†ú - ÎÇ®ÏùÄ Í∞úÏàò: ${store.inputClients.size}`);
      }
    }
  });

  ws.on('error', (err) => {
    console.error(`‚ö†Ô∏è WebSocket ÏóêÎü¨ (${clientIP}):`, err.message);
    // ÏóêÎü¨ Ïãú Î™®Îì† Îß§Ïû•ÏóêÏÑú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†úÍ±∞
    for (const storeKey in stores) {
      const store = stores[storeKey];
      removeClient(store.displayClients, ws);
      removeClient(store.inputClients, ws);
    }
  });

  setTimeout(() => {
    if (ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify({ type: 'PING', timestamp: Date.now() }));
      } catch (error) {
        console.error(`‚ùå Ï¥àÍ∏∞ PING Ïã§Ìå® (${clientIP}):`, error.message);
      }
    }
  }, 1000);
});

function processMessage(storeKey, message, clientIP) {
  const store = stores[storeKey];
  let responseData = null;

  if (message.startsWith('MODE:')) {
    const mode = message.substring(5);
    if (mode === 'WAITING' || mode === 'CALL') {
      store.currentDisplayMode = mode;
      responseData = {
        type: 'MODE',
        mode: mode,
        timestamp: new Date().toISOString(),
        triggeredBy: clientIP
      };
      
      console.log(`üîÑ ${store.name} Î™®Îìú Î≥ÄÍ≤Ω: ${mode} (${clientIP})`);
      
      if (mode === 'CALL' && store.currentNumbers.length > 0) {
        setTimeout(() => {
          const callData = {
            type: 'CALL',
            list: [...store.currentNumbers],
            timestamp: new Date().toISOString()
          };
          broadcastToDisplays(storeKey, JSON.stringify(callData));
        }, 100);
      }
    }
  } else if (message.startsWith('CALL:')) {
    const number = parseInt(message.split(':')[1]);
    if (!isNaN(number)) {
      // Î™®Îì† Îß§Ïû•Ïóê Í∏∞Ï°¥ Î≤àÌò∏ Ïû¨Ìò∏Ï∂ú Ïãú ÏàúÏÑú Î≥ÄÍ≤Ω Î°úÏßÅ Ï†ÅÏö©
      const existingIndex = store.currentNumbers.indexOf(number);
      if (existingIndex !== -1) {
        // Í∏∞Ï°¥ Î≤àÌò∏Î•º Ï†úÍ±∞ÌïòÍ≥† Îß® Îí§Ïóê Ï∂îÍ∞Ä
        store.currentNumbers.splice(existingIndex, 1);
        store.currentNumbers.push(number);
      } else {
        // ÏÉà Î≤àÌò∏ Ï∂îÍ∞Ä
        store.currentNumbers.push(number);
        // 3Î£®Ï†êÏùÄ ÏµúÎåÄ 5Í∞ú, 1Î£®Ï†êÏùÄ ÏµúÎåÄ 10Í∞ú
        const maxNumbers = storeKey === '3ru' ? 5 : 10;
        if (store.currentNumbers.length > maxNumbers) {
          store.currentNumbers.shift();
        }
      }
      
      responseData = {
        type: 'CALL',
        list: [...store.currentNumbers],
        calledNumber: number,
        timestamp: new Date().toISOString(),
        triggeredBy: clientIP
      };
      
      console.log(`üì¢ ${store.name} Ìò∏Ï∂ú: ${number} (${clientIP}) - Î™©Î°ù: [${store.currentNumbers.join(', ')}]`);
    }
  } else if (message.startsWith('CALL_PLUS_ONE:')) {
    // Ìò∏Ï∂ú+1 Í∏∞Îä• (Î™®Îì† Îß§Ïû•)
    const number = parseInt(message.split(':')[1]);
    if (!isNaN(number)) {
      store.currentNumbers.push(number);
      const maxNumbers = storeKey === '3ru' ? 5 : 10;
      if (store.currentNumbers.length > maxNumbers) {
        store.currentNumbers.shift();
      }
      
      responseData = {
        type: 'CALL',
        list: [...store.currentNumbers],
        calledNumber: number,
        timestamp: new Date().toISOString(),
        triggeredBy: clientIP
      };
      
      console.log(`üì¢ ${store.name} Ìò∏Ï∂ú+1: ${number} (${clientIP}) - Î™©Î°ù: [${store.currentNumbers.join(', ')}]`);
    }
  } else if (message.startsWith('CALL_LAST')) {
    // Îπà Ïπ∏ÏúºÎ°ú Ìò∏Ï∂ú Î≤ÑÌäº ÎàåÎ†ÄÏùÑ Îïå ÎßàÏßÄÎßâ Î≤àÌò∏ Ìò∏Ï∂ú
    if (store.currentNumbers.length > 0) {
      const lastNumber = store.currentNumbers[store.currentNumbers.length - 1];
      
      responseData = {
        type: 'CALL',
        list: [...store.currentNumbers],
        calledNumber: lastNumber,
        timestamp: new Date().toISOString(),
        triggeredBy: clientIP
      };
      
      console.log(`üì¢ ${store.name} ÎßàÏßÄÎßâ Î≤àÌò∏ Ïû¨Ìò∏Ï∂ú: ${lastNumber} (${clientIP}) - Î™©Î°ù: [${store.currentNumbers.join(', ')}]`);
    }
  } else if (message.startsWith('SEQUENCE_NEW:')) {
    // ÏÉàÎ°úÏö¥ Ïó∞ÏÜç Ìò∏Ï∂ú Î°úÏßÅ (Î™®Îì† Îß§Ïû•)
	  const numbersStr = message.substring(13);
	  const newNumbers = numbersStr.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
	  
	  if (newNumbers.length > 0) {
		const maxNumbers = storeKey === '3ru' ? 5 : 10;
		store.currentNumbers = newNumbers.slice(0, maxNumbers);
		const lastNumber = store.currentNumbers[store.currentNumbers.length - 1];
		
		responseData = {
		  type: 'CALL',
		  list: [...store.currentNumbers],
		  calledNumber: lastNumber,
		  calledNumbers: [...store.currentNumbers], // üî• Ïù¥ Ï§Ñ Ï∂îÍ∞Ä
		  timestamp: new Date().toISOString(),
		  triggeredBy: clientIP
		};
		
		console.log(`üì¢ ${store.name} ÏÉàÎ°úÏö¥ Ïó∞ÏÜç Ìò∏Ï∂ú: [${newNumbers.join(', ')}] (${clientIP})`);
	  }
  } else if (message.startsWith('SEQUENCE:')) {
    // Í∏∞Ï°¥ Ïó∞ÏÜç Ìò∏Ï∂ú (Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
    const numbersStr = message.substring(9);
    const newNumbers = numbersStr.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
    
    if (newNumbers.length > 0) {
      const maxNumbers = storeKey === '3ru' ? 5 : 10;
      store.currentNumbers = newNumbers.slice(0, maxNumbers);
      
      const lastNumber = store.currentNumbers[store.currentNumbers.length - 1];
      
      responseData = {
        type: 'CALL',
        list: [...store.currentNumbers],
        calledNumber: lastNumber,
        timestamp: new Date().toISOString(),
        triggeredBy: clientIP
      };
      
      console.log(`üì¢ ${store.name} Ïó∞ÏÜç Ìò∏Ï∂ú: [${newNumbers.join(', ')}] (${clientIP})`);
    }
  } else if (message.startsWith('STATUS:')) {
    const statusText = message.substring(7);
    responseData = {
      type: 'STATUS',
      text: statusText,
      timestamp: new Date().toISOString(),
      triggeredBy: clientIP
    };
    
    console.log(`üìä ${store.name} ÏÉÅÌÉú Î©îÏãúÏßÄ: "${statusText}" (${clientIP})`);
  } else if (message.startsWith('AUDIO:')) {
	  const audioType = message.substring(6);
	  responseData = {
		type: 'AUDIO',
		audioType: audioType,
		timestamp: new Date().toISOString(),
		triggeredBy: clientIP
	  };
	  
	  console.log(`üîä ${store.name} Ïò§ÎîîÏò§ Ïû¨ÏÉù ÏöîÏ≤≠: ${audioType} (${clientIP})`);
  } else if (message.startsWith('MSG:')) {
    const text = message.substring(4);
    
    if (storeKey === '1ru') {
      const serveUntilMatch = text.match(/(\d+)Î≤à ÏÜêÎãòÍπåÏßÄ ÎìúÎ¶ΩÎãàÎã§/);
      if (serveUntilMatch) {
        const targetNumber = parseInt(serveUntilMatch[1]);
        
        if (!store.currentNumbers.includes(targetNumber)) {
          store.currentNumbers.push(targetNumber);
          
          if (store.currentNumbers.length > 10) {
            store.currentNumbers.shift();
          }
        }
        
        responseData = {
          type: 'SERVE_UNTIL',
          text: text,
          number: targetNumber,
          currentNumbers: [...store.currentNumbers],
          timestamp: new Date().toISOString(),
          triggeredBy: clientIP
        };
        
        console.log(`üçΩÔ∏è ${store.name} ${targetNumber}Î≤à ÏÜêÎãòÍπåÏßÄ ÏÑúÎπô: "${text}" (${clientIP}) - Î™©Î°ù: [${store.currentNumbers.join(', ')}]`);
      } else {
        responseData = {
          type: 'MSG',
          text: text,
          timestamp: new Date().toISOString(),
          triggeredBy: clientIP
        };
        
        console.log(`üí¨ ${store.name} Î©îÏãúÏßÄ: "${text}" (${clientIP})`);
      }
    } else {
      responseData = {
        type: 'MSG',
        text: text,
        timestamp: new Date().toISOString(),
        triggeredBy: clientIP
      };
      
      console.log(`üí¨ ${store.name} Î©îÏãúÏßÄ: "${text}" (${clientIP})`);
    }
  } else if (message.startsWith('TIME:') && storeKey === '1ru') {
    const parts = message.split(':');
    if (parts.length >= 3) {
      const sam = parseInt(parts[1]);
      const noodle = parseInt(parts[2]);
      if (!isNaN(sam) && !isNaN(noodle)) {
        responseData = {
          type: 'TIME',
          sam: sam,
          noodle: noodle,
          timestamp: new Date().toISOString(),
          triggeredBy: clientIP
        };
        
        console.log(`‚è± ${store.name} ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏: ÏÇºÍ≤πÏÇ¥ ${sam}Î∂Ñ, Íµ≠Ïàò ${noodle}Î∂Ñ (${clientIP})`);
      }
    }
  } else if (message === 'CLEAR') {
    store.currentNumbers = [];
    responseData = {
      type: 'CALL',
      list: [],
      timestamp: new Date().toISOString(),
      triggeredBy: clientIP
    };
    
    console.log(`üóëÔ∏è ${store.name} Î™®Îì† Î≤àÌò∏ ÏßÄÏõÄ (${clientIP})`);
  }

  if (responseData) {
    const sent = broadcastToDisplays(storeKey, JSON.stringify(responseData));
    console.log(`üì° ${store.name} ${sent}Í∞ú ÎîîÏä§ÌîåÎ†àÏù¥Ïóê Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏`);
    
    if (responseData.type === 'CALL' || responseData.type === 'SERVE_UNTIL') {
      notifyInputClients(storeKey, {
        type: 'CALL',
        list: [...store.currentNumbers],
        timestamp: responseData.timestamp
      });
    }
  }
}

function broadcastToDisplays(storeKey, message) {
  const store = stores[storeKey];
  let sentCount = 0;
  const deadClients = [];
  
  store.displayClients.forEach((clientInfo, ws) => {
    if (ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(message);
        sentCount++;
      } catch (error) {
        console.error(`‚ùå ${store.name} ÎîîÏä§ÌîåÎ†àÏù¥ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ïã§Ìå®:`, error.message);
        deadClients.push(ws);
      }
    } else {
      deadClients.push(ws);
    }
  });
  
  deadClients.forEach(ws => removeClient(store.displayClients, ws));
  return sentCount;
}

function notifyInputClients(storeKey, data) {
  const store = stores[storeKey];
  const message = JSON.stringify(data);
  let sentCount = 0;
  const deadClients = [];
  
  store.inputClients.forEach((clientInfo, ws) => {
    if (ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(message);
        sentCount++;
      } catch (error) {
        console.error(`‚ùå ${store.name} ÏûÖÎ†• ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏïåÎ¶º Ïã§Ìå®:`, error.message);
        deadClients.push(ws);
      }
    } else {
      deadClients.push(ws);
    }
  });
  
  deadClients.forEach(ws => removeClient(store.inputClients, ws));
  
  if (sentCount > 0) {
    console.log(`üì± ${store.name} ${sentCount}Í∞ú ÏûÖÎ†• ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê ÏïåÎ¶º`);
  }
}

server.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ ÌÜµÎπ± Îã§Ï§ë Îß§Ïû• Ìò∏Ï∂úÎ≤® ÏãúÏä§ÌÖú ÏãúÏûë!`);
  console.log(`üì± 3Î£®Ï†ê Ìò∏Ï∂ú: http://localhost:${PORT}/input.html`);
  console.log(`üì± 1Î£®Ï†ê Ìò∏Ï∂ú: http://localhost:${PORT}/input1.html`);
  console.log(`üñ•Ô∏è 3Î£®Ï†ê ÎîîÏä§ÌîåÎ†àÏù¥: http://localhost:${PORT}/display.html`);
  console.log(`üñ•Ô∏è 1Î£®Ï†ê ÎîîÏä§ÌîåÎ†àÏù¥: http://localhost:${PORT}/display1.html`);
  console.log(`üí° Ïô∏Î∂Ä Ï†ëÏÜç: http://[ÏÑúÎ≤ÑIP]:${PORT}`);
  console.log(`üìä ÏÉÅÌÉú ÌôïÏù∏: http://localhost:${PORT}/health`);
  console.log(`‚è∞ ${new Date().toLocaleString()}`);
  
  process.on('SIGTERM', gracefulShutdown);
  process.on('SIGINT', gracefulShutdown);
  
  function gracefulShutdown(signal) {
    console.log(`üõë ${signal} Ïã†Ìò∏ Î∞õÏùå - Ï†ïÎ¶¨ ÏãúÏûë`);
    
    clearInterval(heartbeatTimer);
    clearInterval(cleanupTimer);
    
    const shutdownMessage = JSON.stringify({
      type: 'SERVER_SHUTDOWN',
      message: 'ÏÑúÎ≤ÑÍ∞Ä Í≥ß Ï¢ÖÎ£åÎê©ÎãàÎã§',
      timestamp: new Date().toISOString()
    });
    
    for (const storeKey in stores) {
      const store = stores[storeKey];
      
      store.displayClients.forEach((clientInfo, ws) => {
        if (ws.readyState === WebSocket.OPEN) {
          try {
            ws.send(shutdownMessage);
            ws.close(1001, 'Server shutting down');
          } catch (error) {
            console.error(`${store.name} ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¢ÖÎ£å ÏïåÎ¶º Ïã§Ìå®:`, error.message);
          }
        }
      });
      
      store.inputClients.forEach((clientInfo, ws) => {
        if (ws.readyState === WebSocket.OPEN) {
          try {
            ws.send(shutdownMessage);
            ws.close(1001, 'Server shutting down');
          } catch (error) {
            console.error(`${store.name} ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¢ÖÎ£å ÏïåÎ¶º Ïã§Ìå®:`, error.message);
          }
        }
      });
    }
    
    wss.close(() => {
      console.log('üîå WebSocket ÏÑúÎ≤Ñ Ï¢ÖÎ£åÎê®');
      
      server.close(() => {
        console.log('‚úÖ HTTP ÏÑúÎ≤Ñ Ï†ïÏÉÅ Ï¢ÖÎ£åÎê®');
        process.exit(0);
      });
    });
    
    setTimeout(() => {
      console.log('‚ö° Í∞ïÏ†ú Ï¢ÖÎ£å');
      process.exit(1);
    }, 10000);
  }
});